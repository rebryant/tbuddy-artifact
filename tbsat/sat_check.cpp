/*========================================================================
  Copyright (c) 2022 Randal E. Bryant, Carnegie Mellon University
  
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
========================================================================*/


#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "clause.h"

// Check all solutions generated by SAT checker
void usage(char *name) {
    printf("Usage: %s [-h] [-v VLEVEL] -i CFILE [-s SFILE]\n", name);
    printf("  -h         Print this message\n");
    printf("  -v VLEVEL  Specify verbosity level (0-2)\n");
    printf("  -i CFILE   Specify input CNF formula\n");
    printf("  -s SFILE   Specify file containing solution.  Default is standard input\n");
    exit(0);
}


// Skip line.  Return either \n or EOF
static int skip_line(FILE *infile) {
    int c;
    while ((c = getc(infile)) != EOF) {
	if (c == '\n')
	    return c;
    }
    return c;
}

// Skip any whitespace characters other than newline
// Read and return either EOF or first non-space character (possibly newline)
static int skip_space(FILE *infile) {
    int c;
    while ((c = getc(infile)) != EOF) {
	if (c == '\n')
	    return c;
	if (!isspace(c)) {
	    return c;
	}
    }
    return c;
}

// Read rest of line, trimming off leading spaces and trailing newline.
// Return line length
static int get_line(FILE *infile, char *buf, int maxlen) {
    int c = skip_space(infile);
    int pos = 0;
    if (c == EOF || c == '\n') {
	buf[pos] = 0;
	return pos;
    }
    buf[pos++] = c;
    while (true) {
	c = getc(infile);
	if (c == '\n' || c == EOF) {
	    if (pos < maxlen)
		buf[pos] = 0;
	    else
		buf[--pos] = 0;
	    break;
	}
	if (pos < maxlen)
	    buf[pos++] = c;
    }
    return pos;
}

// Read line and parse as set of numbers.  Return either \n or EOF
static int get_numbers(FILE *infile, std::vector<int> &numbers) {
    int c;
    int val;
    numbers.resize(0,0);
    while ((c = getc(infile)) != EOF) {
	if (c == '\n')
	    break;
	if (isspace(c))
	    continue;
	ungetc(c, infile);
	if (fscanf(infile, "%d", &val) != 1) {
	    break;
	}
	numbers.push_back(val);
    }
    return c;
}

static char read_solution(FILE *infile, char *assignment, int var_count) {
    std::vector<int> lits;
    memset(assignment, 2, var_count);
    char c = get_numbers(infile, lits);
    if (c == EOF && lits.size() == 0)
	return c;
    for (int lit : lits) {
	if (lit == 0)
	    break;
	else if (lit < 0)
	    assignment[-lit-1] = 0;
	else
	    assignment[lit-1] = 1;
    }
    return '\n';
}

static void run_checks(CNF &cnf, FILE *sfile, int verblevel) {
    int line = 1;
    int cid;
    int check_count = 0;
    int ok_count = 0;
    int var_count = cnf.max_variable();
    bool error = false;
    char *assignment = new char[var_count];
    char linebuf[1024];
    int len;
    if (verblevel > 0)
	std::cout << std::endl << "Checking solutions" << std::endl;

    while (true) {
	int c;
	if ((c = skip_space(sfile)) == EOF)
	    break;
	switch(c) {
	case '\n':
	    line++;
	    break;
	case 'c':
	    c = skip_line(sfile);
	    line++;
	    break;
	case 's':
	    len = get_line(sfile, linebuf, 1024);
	    line++;
	    if (len > 0 && strcmp(linebuf, "SATISFIABLE") == 0) {
		break;
	    } else if (len > 0 && strcmp(linebuf, "UNSATISFIABLE") == 0) {
		std::cout << "UNSATISFIABLE" << std::endl;
		return;
	    } else {
		std::cout << "ERROR: Line #"  << line << ".  Cannot decipher solution status" << std::endl;
		error = true;
		return;
	    }
	case 'v':
	    c = read_solution(sfile, assignment, var_count);
	    line++;
	    if (c == EOF)
		break;
	    cid = cnf.satisfied(assignment);
	    check_count ++;
	    if (cid == 0) {
		if (verblevel >= 2)
		    std::cout << "Line #" << line << ".  solution #" << check_count << ".  Satisfied" << std::endl;
		ok_count ++;
		break;
	    }
	    if (verblevel >= 1) {
		std::cout << "ERROR: Line #" << line << 
		    ", solution #" << check_count <<
		    " violates Clause #" << cid << std::endl;
		error = true;
	    }
	    break;
	default:
	    error = true;
	    std::cout << "ERROR.  Line #" << line << ".  Unknown line type" << std::endl;
	}
    }
    if (!error) {
	if (ok_count == check_count) {
	    if (verblevel >= 1)
		std::cout << ok_count << "/" << check_count << " solutions satisfied" << std::endl;
	    if (check_count > 0)
		std::cout << "VERIFIED" << std::endl;
	} else {
	    std::cout << "ERROR: Only " << ok_count << "/" << check_count << " solutions satisfied" << std::endl;
	}
    }
}

int main(int argc, char *argv[]) {
    FILE *cnf_file = NULL;
    FILE *solution_file = stdin;
    int verb = 1;
    int c;
    while ((c = getopt(argc, argv, "hv:i:s:")) != -1) {
	char buf[2] = { (char) c, '\0' };
	switch(c) {
	case 'h':
	    usage(argv[0]);
	    break;
	case 'v':
	    verb = atoi(optarg);
	    break;
	case 'i':
	    cnf_file = fopen(optarg, "r");
	    if (cnf_file == NULL) {
		std::cerr << "Couldn't open file " << optarg << std::endl;
		exit(0);
	    }
	    break;
	case 's':
	    solution_file = fopen(optarg, "r");
	    if (solution_file == NULL) {
		std::cout << "ERROR: Couldn't open file " << optarg << std::endl;
		exit(1);
	    }
	    break;
	default:
	    std::cout << "ERROR: Unknown option '" << buf << "'" << std::endl;
	    usage(argv[0]);
	}
    }
    if (!cnf_file) {
	std::cerr << "ERROR: Must specify CNF file" << std::endl;
	usage(argv[0]);
    }
    if (!solution_file) {
	std::cerr << "ERROR: Must specify solution file" << std::endl;
	usage(argv[0]);
    }
    CNF cset = CNF(cnf_file);
    fclose(cnf_file);
    run_checks(cset, solution_file, verb);
    return 0;
}
